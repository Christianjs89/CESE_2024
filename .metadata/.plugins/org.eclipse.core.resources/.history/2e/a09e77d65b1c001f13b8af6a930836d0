/*
 * asm_func.S
 *
 *  Created on: May 23, 2024
 *      Author: chris
 */

.text 	// Secci칩n de texto: se indica que en esta secci칩n hay c칩digo para ejecutar

.syntax unified		// Uso del UAL
.thumb	// El ISA que se utilizar치 es Thumb-2

// .global labels
.global pack32to16
.global max
.global downSample
.global invertir


/* -------------- GP2-EJ1 PACK32TO16  -------------- */
/*
void pack32to16 (int32_t * vectorIn, int16_t *vectorOut, uint32_t longitud)

Parametros entrada:
	R0 vectorIn dir
	R1 vectorOut dir
	R2 longitud
	R3 *libre*

Retorno:
	void
*/

.thumb_func
pack32to16:
	CBZ R0, exit1 // compare and branch if zero: si pointer de vector es NULL salir
	CBZ R1, exit1 // idem

	loop1:
		SUB R2, #1 // decrementar contador, comienza en longitud-1
		LDR R3, [R0, R2, LSL #2] // cargar elementos de int32 en el R3 -> R3 = *(R0+(R2<<2))
		ASR R3, R3, #16 // extraer 16 bits mas significativos con un shift de 16 a la derecha
		STRH R3, [R1, R2, LSL #1] // almacenar el valor del R3 en memoria con int16 -> *(R1+(R2<<2))=*(R1+(R2+2)=R4

		CBZ R2, exit1 // ir a exit si el contador R2=0
		B loop1 // volver al loop1 si R2 !=0

	exit1:
		BX LR // branch al link register con dir en caller

/* -------------- GP2-EJ1 PACK32TO16  -------------- */


/* -------------- GP2-EJ2 MAX  -------------- */
/*
uint32_t max (int32_t * vectorIn, uint32_t longitud)

Parametros de entrada:
	R0 vectorIn >> dir
	R1 longitud >> indice
	R2 *libre* >> almacenar maximo valor al momento
	R3 *libre* >> almacenar indice del maximo al momento
	R4 *ocupado, hacer push/pop al stack* >> cargar valores a comparar con R2

Retorno:
	uint32_t max

*/
.thumb_func
max:
	PUSH {LR}
	CBZ R0, exit2
	PUSH {R4} // utilizar R4 para cargar el valor a comparar
	// Comenzar tomando N-1 como maximo
	BL maxInit

	// recorrer vectorIn comparando cada elemento con el 'mayor' almacenado en R2, y el indice en R3
	loop2:
		SUB R1, #1 // decrementar contador, comienza en N-2
		LDR R4, [R0, R1, LSL #2] // cargar valor a comparar con R2 en R4
		// If-THEN-ELSE
		CMP R4, R2// comparar R2 'maximo' con R4
		// si R4>R2 entonces mover R4 a R2, y R1 (indice) a R3, sino R2 sigue siendo el max
		ITT GT
		MOVGT R2, R4 // R2=R4 nuevo max
		MOVGT R3, R1 // R3=R1 indice actual correspondiente a R4
		// checkear indice y salir o volver al loop2
		CBZ R1, exit2 // ir a exit2 si el contador R1=0
		B loop2 // volver al loop2 si R1 !=0

	exit2:
		MOV R0, R3 // almacenar en R0 (retorno), el indice del maximo que estaba en R3
		POP {R4}
		POP {LR}
		BX LR


maxInit:
	PUSH {LR}
	SUB R1, #1 // decrementar contador, comienza en N-1
	LDR R2, [R0, R1, LSL #2] // cargar en R2, el valor de N-1
	MOV R3, R1 // cargar en R3 el valor del indice N-1 que esta en R1
	POP {LR}
	BX LR // alternativa: B loop2 sin hacer push/pop


/* -------------- GP2-EJ2 MAX  -------------- */




/* -------------- GP2-EJ3 DOWNSAMPLE  -------------- */
/*
void downSample (int32_t * vectorIn, int32_t * vectorOut, uint32_t longitud, uint32_t N)

Parametros de entrada:
	R0 vectorIn
	R1 vectorOut >> vector con menos muestras
	R2 longitud >> cantidad elementos vectorIn, multiplo de N, usar de indice
	R3 N >> saltear cada N muestras
	R4 *ocupado, hacer push/pop* >> usar para almacenar el valor del vector
	R5 *ocupado, hacer push/pop* >> indice2 usar como indice del vector de salida
	R6 *ocupado, hacer push/pop* >> contador de omision

Retorno:
	void

	uint32_t longitud2 = longitud * (N-1) / N;
	uint32_t indice2 = longitud2-1;
	uint32_t indice = longitud-1;
	uint32_t cuenta = N; // contador de omision

    while(1){
    if( (indice == longitud-1)||(cuenta == 0) ){
    	cuenta = N; // resetear contador
	     // no almacenar
    } else {
	    vectorOut[indice2] = vectorIn[indice];
	    indice2--;
    }
    if(indice == 0) break;
    cuenta--;
    indice--;
*/

.thumb_func
downSample:
	PUSH {R4-R6}
	CBZ R0, exit3
	CBZ R1, exit3

	B longVectorOut
	_longVectorOut:

	MOV R6, R3 // cuenta = N
	SUB R2, #1 // indice-1 >> siempre saltear el ultimo

	// recorrer vectorIn almacenando en vectorOut, excepto si el indice es divisible por N (indice%N == 0 >> no guardar)
	loop3:
		SUB R2, #1 // indice-1
		SUB R6, #1 // count-1
		// salto condicional a almacenar o no en vectorOut
		CMP R6, #0 // contador omision = 0 ?
		BEQ resetCount // reset contador omision R6=N si fue 0
		BNE vectorOut // si no fue 0, almacenar en vector de salida
		_condExit:
		CBZ R2, exit3 // ir a exit3 si el indice R2=0
		B loop3 // volver al loop2 si R1 !=0

exit3:
	POP {R4-R6}
	BX LR

longVectorOut: // R5 longitud2 vectorOut, R3=N, R2 long vectorIn
	// longitud2 = longitud * (N-1) / N
	SUB R5, R3, #1 // R5=R3-1=N-1
	MUL R5, R5, R2 // R5 = R5*R2 = long-vectorIn * (N-1)
	UDIV R5, R5, R3 // R5=R5/R3=long-vectorIn *(N-1)/N
	B _longVectorOut

resetCount:
	MOV R6, R3 // resetear cuenta = N
	B _condExit

vectorOut:
	SUB R5, #1 // indice2-1
	LDR R4, [R0, R2, LSL #2] // cargar elemento vectorIn en R4=[R0+(R2x4)]
	STR R4, [R1, R5, LSL #2] // guardar elemento en vectorOut [R1+(R5x4)]=R4
	B _condExit


/* -------------- GP2-EJ3 DOWNSAMPLE  -------------- */




/* -------------- GP2-EJ4 INVERTIR  -------------- */
/*
void invertir (uint16_t * vector, uint32_t longitud)

Parametros de entrada:
	R0 vectorIn
	R1 longitud, contador descendente posicion alta
	R2 *libre* >> buffer carga item bajo
	R3 *libre* >> buffer carga item alto
	R4 *ocupado, hacer push/pop* >> contador ascendente, posicion baja

Retorno:
	void
*/

.thumb_func
invertir:
	PUSH {R4}
	CBZ R0, exit4

	SUB R1, #1 // decrementar indice alto e inicializar en longitud-1
	MOV R4, #0 // inicializar indice bajo en 0

	loop4:
		LDRH R2, [R0, R4, LSL #1] //cargar en buffer bajo R2 item posicion baja
		LDRH R3, [R0, R1, LSL #1] // cargar en buffer alto R3 item posicion alta
		STRH // guardar en memoria, item bajo R2 como item alto
		STRH  // guardar en memoria, item alto R3 como item bajo


		SUB R1, #1 // R1-1, contador alto
		ADD R4, #1 // R4+1, contador bajo
		// cuando se encuentren los indices o el indice bajo sea mayor al alto, salir
		CMP R4, R1
		BEQ exit4




exit4:
	POP {R4}
	BX LR





/* -------------- GP2-EJ4 INVERTIR  -------------- */









